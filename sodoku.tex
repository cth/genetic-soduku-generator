\documentclass{article}
\usepackage{epsfig}

\author{Christian Theil Have\\christiantheilhave@gmail.dk}
\title{Sodoku generator}

\begin{document}

\maketitle

\section{Introduction}

This is a a sodoku generator written in Standard ML.
It's not very fast (this is partly because of SML, see
implementation issues).

I've experimented with various selection, breeding, 
mutation and fitness functions with various results
that should become apparent in this report.

\subsection{Representation}

I represent the sodoku board as a list of integers. I've 
created some functions for working with this as a sodoku 
board. The important ones are:

\begin{itemize}
\item 
  \emph{mk\_board(size)} This creates a new sodoku board which
  is randomly initialized (with values from 1-size). Size is an
  integer that has an integer square root (such as 4 or 9) 
\item \emph{nth\_row(n,board)} 
    Creates an integer list corresponding to row n (first is 1) in the
    sodoku board. 
\item \emph{nth\_col(n,board)}
    Creates an integer list corresponding to column n (first is 1) in the
    sodoku board. 
\item \emph{nth\_quadrant(n,board)}
    Creates an integer list corresponding to quadrant n (first is 1) in the
    sodoku board. Quadrants are numbered in the following fashion:
\begin{verbatim}
  1 | 2 | 3
  ---------  
  4 | 5 | 6
  ---------
  7 | 8 | 9
\end{verbatim}

\end{itemize}

Representing all elements of the sodoku board makes it easy to check
correctness of a sodoku. All sub elements (rows,columns,quadrants) are
list that must contain the numbers from 1 to size, in order to be
correct. A sodoku board is correct if all it's sub elements are
correct.


\subsection{Fitness/utility function}

I devised two different fitness/utility functions.

The first one is the sum of correct rows, correct columns and
correct quadrants. A solution is a board that has maximum 
fitness (27 in the of a 9x9 sodoku and 12 in the case of a 4x4 
sodoku). This fitness
function wasn't really fine grained enough; so instead I created
the second. 

The second one is similar to the first, but instead calculates 
the sum of ``correct numbers'' within each row, column and quadrant.
This yields a maximum utility of 48 for a 4x4 sodoku and 243 for a 
9x9 sodoku.

The relevant functions in the code are:
\begin{itemize}
\item checkline
\item checkline\_count
\item utility1
\item utility2
\item is\_solution1
\item is\_solution2
\end{itemize}

\paragraph{Possible improvements:}

I believe that the fitness function could be improved a lot though.
For instance, when a board with a high fitness (using second fitness
function) is found, the fitness of board could be adjusted as follows:
\begin{itemize}
\item Remove elements that does not contribute to fitness 
\item Try to solve the remaining board using exhaustive search (if the
  fitness of the board is high enough, this should be a quite limited search
  space). 
\item If no solution is found, rate the the board with lower fitness.
\end{itemize}

\subsection{Selection strategy}

I primarily used elitism, but this also meant finding local maximums.
I used approaches to avoid this, but they generally require larger generation
sizes or more generations to evolve.

\subsubsection{Elitism}
The elitism I've implemented sorts the boards produced mutations
and crossovers by their utility. It then take the best of the 
boards from the head of the list.

The relevant functions in the code are:
\begin{itemize}
\item elite
\item utility\_sort
\end{itemize}

I've used elitism as a means to select the next generation.
This approach seems to select a number of approximately fit 
boards in short time. 

However the boards of the generations become very similar after a
while. Following generations doesn't change much after this. The 
reason for this is that mutations often lead to fitness 
improvements in the first generations, but then mutations becomes 
less likely to lead to improvements. 
The problem with elitism is that does not allow ``backtracking'',
and you can get stuck at local maxima. 

I tried to optimize this using a number of strategies. 

\subsubsection{Random walk}
This approach just picks the boards for the next generation 
at random. I produces a lot of very different boards (gets 
around search-space), but doesn't converge unless you are 
really lucky ;-) Look a the function \emph{rselect} in the 
code to see how it works.

\subsubsection{Combined}

The \emph{combined} approach picks out half of the boards using 
the \emph{elite} function and half using the \emph{rselect} 
function. It doesn't really work that well. 

I also had a another function which picked a number of 
boards using \emph{rselect} and then picks the best of 
those using the \emph{elite} function. This seemed to
work ok, except that it sometimes abandoned a board
with high utility (So utility might actually drop from 
generation to generation).

\subsubsection{Other approaches}

One annoyance with the \emph{elite} function was that it
produced a lot of duplicate boards. I did an optimization
where I removed duplicates from from the generation. 


\subsection{Breeding}

It's difficult to find a good splitting point since the
rows, columns and quadrants intersect each other.

So I ended up creating a crossover function, which just combines sodokus at
random each number it decides randomly whether to take it from 
the ``father'' or ``mother''. The unfortunate consequence is that 
the resulting sodokus have a lousy utility, unless the ``father'' and
``mother'' are very similar. Consequentially I ended up having a lot of very similar
boards in my generations (I mostly used the elitism approach). 

I found that asexual breeding was probably a better approach and
in many of my experiments I abandoned crossovers and only 
did mutations.

\subsection{Mutation}

\subsubsection{Random mutation function}

The random mutation function mutates every number in a sodoku
with a certain probability. This works fairly well, but has some
issues:

It's blind: Some (most) mutations leads to worse offspring.
The closer the sodokus are to being solved, the larger the 
probability that a mutation will lead to something with a worse
fitness rating. This also means that at some point evolutions
slows down a lot.

The following is a list of the number of generations it took
to find a solution to a 4x4 sodoku using a random mutation
and crossover function, a generation size of 4 and mutation 
rate of 4: \emph{12, 983, 133, 2786,  35, 5737}. Very different 
results, indeed. In every case, the algorithm converged to 
a fitness above 40 within the first five generations. This nicely
illustrate how the evolution slows down, because the mutations
likehood of improving the fitness becomes less and less.

\subsubsection{Swap mutation function}

When I generate boards for the initial generation, they contain 
all the right numbers for a solved sodoku. The reason I do this is
to be able to do mutation by swapping numbers instead
of just replacing them at random. 

%Consider the most difficult case where only two fields
%are wrong: Picking the right ones to swap has a probability 
%of $1/16 * 1/16 =1/256$. Picking one of right ones for random mutation has a 
%probability of $1/16$, and the probability of picking the right number 
%of ithas a probability of $1/9$, so $1/9 * 1/16 = 1/144$. This has to
%be done twice to achieve the same effect as a the swap, so the final
%probabilty is: $1/288$. 

It turned out to be a bad optimization, because it frequently got 
stuck at local maximums, like the one below:

\begin{verbatim}
Evolving generation 230
230 46 46
Total utility; 46
Utility: 46
Best board
3 4 1 2 
1 2 4 3 
2 3 3 1 
4 1 2 4 
\end{verbatim}

In the case above there is two 3's in line row 3. But swapping any
of these with any other number leads to a worse fitness!

The swapping is more efficient than the random mutator, no doubt. I 
has evolved 9x9 sodokus to to a fitness of 239 (only two from being
solved). But it has this problem with local maxima. 

\subsubsection{(not so) Clever mutation function}
This function (\emph{cmutate}) mutates only if it improves the utility rating.
For each field it tries to mutate the field such that it improves
the utility of board. If it cannot find such a mutation, it leaves
the field untouched. I guess this is cheating, but it does provide
an advantage compared to the the random mutation function.

It also have some issues though. It might still get stuck in
local maxima since solving a board might require mutations
that reduce utility. The selection strategy can compensate (to a
degree) for this, but this requires larger generations.

I have evolved 9x9 boards with a high utility with this mutation
function, but it has never solved a 9x9 board for me. See below
for an example:

\begin{verbatim}
Evolving generation 18
18 6866 229
Total utility; 6866
Utility: 229
Best board
5 4 9  3 7 1  4 6 8
7 3 2  4 6 8  1 5 9
1 8 6  9 4 5  3 7 2

4 2 5  7 3 6  8 1 3
6 9 7  2 1 2  7 9 6
3 1 8  6 9 7  5 2 4

2 7 3  5 4 9  6 8 1
9 5 1  8 6 4  2 3 7
8 6 4  1 2 3  9 4 5
\end{verbatim}

I have an other function \emph{cswap} that does roughly the same using the
swapping approach. It only swaps two numbers if it improves fitness,
but it has the same local maxima problems as the simple swap mutator.

Both of the variants find solutions to 4x4 sodokus extremly fast
(usually within 5 generations or less). Below is particularly
nice run with the cswap mutator, that finds three solutions with a
generation of four boards in the first generation:

\begin{verbatim}
- test(4,4,0);
Evolving generation 0
0 131 34
Total utility; 131
Utility: 34
Best board
4 4 3 4 
2 1 2 3 
3 3 2 4 
1 1 1 2 

Evolving generation 1
1 190 48
Total utility; 190
Utility: 48
Best board
2 3 1 4 
4 1 2 3 
3 2 4 1 
1 4 3 2 


Found a solution: 
2 3 1 4 
4 1 2 3 
3 2 4 1 
1 4 3 2 

Found a solution: 
4 3 2 1 
1 2 3 4 
3 1 4 2 
2 4 1 3 

Found a solution: 
2 1 4 3 
3 4 1 2 
4 3 2 1 
1 2 3 4 
\end{verbatim}

Running cswap with 9x9 boards takes a long time, but will get very
close to solution in \emph{very} few generations. The run below shows evolution
one board in three generations:

\begin{verbatim}
Evolving generation 0
0 166 166
Total utility; 166
Utility: 166
Best board
4 8 5 5 8 2 1 5 6 
8 9 2 9 1 6 3 2 8 
3 1 9 6 5 7 1 5 4 
7 8 7 6 1 1 7 2 3 
7 6 5 5 9 2 3 7 8 
9 3 2 6 5 1 4 9 5 
3 4 3 1 7 7 8 4 4 
2 6 2 4 7 4 9 9 6 
4 3 8 8 6 3 9 2 1 

Evolving generation 1
1 238 238
Total utility; 238
Utility: 238
Best board
4 3 5 3 8 2 1 9 6 
6 7 2 4 1 9 3 5 8 
9 1 8 6 5 7 7 2 4 
1 8 4 9 6 5 2 7 3 
5 6 3 7 2 8 4 1 9 
7 2 9 1 4 3 6 8 5 
3 9 6 2 7 1 8 4 7 
2 5 7 8 9 6 5 3 1 
8 4 1 5 3 4 9 6 2 

Evolving generation 2
2 239 239
Total utility; 239
Utility: 239
Best board
4 3 5 3 8 2 1 9 6 
6 7 2 4 1 9 3 5 8 
9 1 8 6 5 7 7 2 4 
1 8 4 9 6 5 2 7 3 
5 6 3 7 2 8 4 1 9 
7 2 9 1 4 3 6 8 5 
3 9 6 2 7 1 8 4 7 
2 4 7 8 9 6 5 3 1 
8 5 1 5 3 4 9 6 2 

\end{verbatim}

Only three in fitness rating from being a solution, and here we have
the local maximum problem again (even though more complex this
time). Bummer.

\subsubsection{Combinations}

Of course, the different mutation functions can be combined. If 
an other approach than pure elitism is used this could work well.
With elitism we still have the local maximum problem, since 
random mutations with worse fitness (it can be seen  as
``backtracking'') would be discarded.

\subsection{Implementation issues}
I've implemented the sodoku generation in Standard ML.
As a consequence, it's not very fast. The reason for
this is that ML doesn't handle ``mutations'' very well.
It's a functional language so data cannot be updated 
destructively. Instead it creates new data structures
for each generation etc. Working with large generations
this turned out to be very slow.

\subsection{Conclusion}

It seems plausible to generate sodokus using genetic algorithms.
However, the interdepency of rows, columns and quadrants make it difficult
to make mutations and crossovers. Genetic algoritms will rapidly
``almost solve'' the sodoku. The closer the sodoku is to being solved,
the smaller becomes the likelyhood that a mutation or crossover will 
lead to a board with better fitness. 

It's apparent that mutations at random doesn't do well at solving a
sodoku. Domain knowledge can be used to optimize the process, as seen
with the ``(not so) clever mutation function'' and the \emph{cswap}
mutator. A think it would be a better approach to integrate the domain
knowledge in the fitness function. 

I realized the importance of having a good fitness function. There was 
a huge improvement in using the second one over first. I believe the 
optimisation I described in the section on fitness would improve the 
algorithm significantly. This is an example of how domain knowledge could be
exploited. I didn't implement this, though.

My implementation solves 4x4 sodokus fairly fast (usually). It
will ``almost'' solve 9x9 sodokus fairly fast, but I have not waited
for it so find a perfect solution. Using the same algoritms as I have,
but implementing them in an imperative programming language would 
make the implementation much faster. I didn't foresee this and did not 
have the time to reimplement it. 

\end{document}
